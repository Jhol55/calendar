generator client {
  provider = "prisma-client-js"
  output = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url = env("DATABASE_URL")
}

model user {
  id                  Int      @id @default(autoincrement())
  email               String   @unique
  password            String
  name                String?
  phone               String?
  company             String?
  avatar              String?
  confirmed           Boolean  @default(false)
  role                String   @default("user")
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  chatbot_flows       chatbot_flows[]
}

model licenses {
  id                          Int      @id @default(autoincrement())
  apikey                      String   @unique @db.VarChar(255)
  subdomain                   String?  @db.VarChar(255)
  ip                          String?  @db.VarChar(45)
  url                         String?  @db.VarChar(255)
  port                        Int?
  ssl_path                    String?  @db.Text
  redis_enabled               Boolean  @default(false)
  instance_count              Int      @default(0)
  is_valid                    Boolean  @default(true)
  expires_at                  DateTime?
  last_validation             DateTime @default(now())
  validation_interval_seconds Int      @default(86400)
  last_update_version         Int      @default(647)
  created_at                  DateTime @default(now())
  updated_at                  DateTime @default(now()) @updatedAt
  
  validation_logs             license_validation_logs[]

  @@index([apikey])
  @@index([subdomain])
  @@index([is_valid])
}

model license_validation_logs {
  id                Int       @id @default(autoincrement())
  license_id        Int?
  apikey            String    @db.VarChar(255)
  ip                String?   @db.VarChar(45)
  validation_result Boolean?
  error_message     String?   @db.Text
  validated_at      DateTime  @default(now())
  
  license           licenses? @relation(fields: [license_id], references: [id])

  @@index([license_id])
  @@index([apikey])
}

model instances {
  id                         String   @id
  token                      String   @unique
  status                     String
  paircode                   String
  qrcode                     String
  name                       String
  webhook                    String
  profileName                String
  profilePicUrl              String
  isBusiness                 Boolean  @default(false)
  plataform                  String
  systemName                 String
  owner                      String
  current_presence           String
  lastDisconnect             String
  lastDisconnectReason       String
  adminField01               String
  adminField02               String
  openai_apikey              String
  chatbot_enabled            Boolean  @default(false)
  chatbot_ignoreGroups       Boolean  @default(false)
  chatbot_stopConversation   String
  chatbot_stopMinutes        Int      @default(0)
  chatbot_stopWhenYouSendMsg Int      @default(0)
  created                    String
  updated                    String
  currentTime                String

  chatbot_flows              chatbot_flows[]

  @@index([owner])
  @@index([status])
}

model chatbot_flows {
  id          String    @id @default(uuid())
  name        String    @db.VarChar(255)
  description String?   @db.Text
  nodes       Json      @db.JsonB
  edges       Json      @db.JsonB
  token       String?
  userId      Int?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  instance    instances? @relation(fields: [token], references: [token])
  user        user?      @relation(fields: [userId], references: [id])
  executions  flow_executions[]

  @@index([token])
  @@index([userId])
  @@index([isActive])
}

model flow_executions {
  id          String    @id @default(uuid())
  flowId      String    @db.VarChar(255)
  status      String    @default("running") // running, success, error, stopped
  triggerType String    @default("webhook") // webhook, manual, schedule
  triggerData Json?     @db.JsonB // Dados que dispararam a execução
  startTime   DateTime  @default(now())
  endTime     DateTime?
  duration    Int?      // Duração em milissegundos
  error       String?   @db.Text
  data        Json?     @db.JsonB // Dados de entrada
  result      Json?     @db.JsonB // Dados de saída
  nodeExecutions Json?  @db.JsonB // Execução de cada nó
  
  flow        chatbot_flows @relation(fields: [flowId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([flowId])
  @@index([status])
  @@index([startTime])
  @@index([triggerType])
}

model chatbot_memories {
  id        String    @id @default(uuid())
  userId    String    @db.VarChar(255) // Email do usuário logado
  chave     String    @db.VarChar(255) // Nome da memória
  valor     Json      @db.JsonB        // Valor (JSON flexível)
  expiresAt DateTime? // TTL - null = nunca expira
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@unique([userId, chave])
  @@index([userId])
  @@index([expiresAt])
}

model DataTable {
  id          String   @id @default(uuid())
  userId      String   @db.VarChar(255) // Email do usuário logado
  tableName   String   @db.VarChar(255) // Nome da tabela virtual (ex: "leads", "customers")
  partition   Int      @default(0)      // Número da partição (0, 1, 2, 3...)
  
  schema      Json     @db.JsonB        // Definição das colunas
  data        Json     @db.JsonB        // Array de registros (max 1000 por partição)
  
  recordCount Int      @default(0)      // Quantidade de registros nesta partição
  isFull      Boolean  @default(false)  // true quando atingir MAX_PARTITION_SIZE
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([userId, tableName, partition])
  @@index([userId, tableName])
  @@index([userId, tableName, isFull])
}